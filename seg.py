# -*- coding: utf-8 -*-
"""180227_Assign4 Q6

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1HqwFn35rgs2aTHM-Z9t0wvIR4sZRt27P
"""

import numpy as np
import cv2
from scipy import signal, interpolate
from google.colab.patches import cv2_imshow

def flatter_image(img):
    flat_image = img.flatten()
    edgemin = np.amin(flat_image)
    edgemax = np.amax(flat_image)
    edgedelta = edgemax - edgemin
    return flat_image, edgemin, edgemax,edgedelta
def derived(sigmaspatial, sigmarange, samplespatial, samplerange):

  samplespatial = sigmaspatial if (samplespatial is None) else samplespatial
  samplerange = sigmarange if (samplerange is None) else samplerange
  derivedspatial = sigmaspatial / samplespatial 
  derivedrange = sigmarange / samplerange
  return samplespatial, samplerange, derivedspatial, derivedrange
def sample_dimension(width,height,edgedelta,samplespatial,samplerange,xypadding,zpadding):
  sw = int(np.round((width - 1) / samplespatial) + 1 + 2 * xypadding)
  sh = int(np.round((height - 1) / samplespatial) + 1 + 2 * xypadding)
  sd = int(np.round(edgedelta / samplerange) + 1 + 2 * zpadding)
  return sw, sh, sd
def get_dim(image,xgrid,ygrid,edgemin,samplespatial,xypadding,zpadding,samplerange,sw, sh, sd):
  dimx = np.around(xgrid / samplespatial) + xypadding
  dimy = np.around(ygrid / samplespatial) + xypadding
  dimz = np.around((image - edgemin) / samplerange) + zpadding
  flatx,flaty,flatz = flat_them(dimx,dimy,dimz)
  dim = flatz + flaty * sd + flatx * sw * sd
  dim = np.array(dim, dtype=int)
  return dimx,dimy,dimz,dim
def flat_them(dimx,dimy,dimz):
  flatx = dimx.flatten()
  flaty = dimy.flatten()
  flatz = dimz.flatten()
  return flatx,flaty,flatz
def rt_BF(image, sigmaspatial, sigmarange, samplespatial=None, samplerange=None):

    height = image.shape[0]
    width = image.shape[1]
    
    samplespatial, samplerange, derivedspatial, derivedrange = derived(sigmaspatial, sigmarange, samplespatial, samplerange)

    flat_image, edgemin, edgemax,edgedelta = flatter_image(image)
    
    flat_image = image.flatten()

    xypadding = np.round(2 * derivedspatial + 1)
    zpadding = np.round(2 * derivedrange + 1)

    sw, sh, sd = sample_dimension(width,height,edgedelta,samplespatial,samplerange,xypadding,zpadding)

    df = np.zeros(sh * sw * sd)

    (ygrid, xgrid) = np.meshgrid(range(width), range(height))

    dimx,dimy,dimz,dim= get_dim(image,xgrid,ygrid,edgemin,samplespatial,xypadding,zpadding,samplerange,sw, sh, sd)

    df[dim] = flat_image

    data = df.reshape(sh, sw, sd)
    weights = np.array(data, dtype=bool)

    kerneldim = derivedspatial * 2 + 1
    kerneldep = 2 * derivedrange * 2 + 1


    (gridx, gridy, gridz) = np.meshgrid(range(int(kerneldim)), range(int(kerneldim)), range(int(kerneldep)))

    halfkerneldim = np.round(kerneldim / 2)
    halfkerneldep = np.round(kerneldep / 2)
    gridx -= int(halfkerneldim)
    gridy -= int(halfkerneldim)
    gridz -= int(halfkerneldep)

    gridsqr = ((gridx * gridx + gridy * gridy) / (derivedspatial * derivedspatial)) + ((gridz * gridz) / (derivedrange * derivedrange))
    kernel = np.exp(-0.5 * gridsqr)

    blurweights = signal.fftconvolve(weights, kernel, mode='same')
    blurweights = np.where(blurweights == 0, -2, blurweights)

    blurdata = signal.fftconvolve(data, kernel, mode='same')

    normalblurdata = blurdata / blurweights
    normalblurdata = np.where(blurweights < -1, 0, normalblurdata)

    (ygrid, xgrid) = np.meshgrid(range(width), range(height))

    dimx = (xgrid / samplespatial) + xypadding
    dimy = (ygrid / samplespatial) + xypadding
    dimz = (image - edgemin) / samplerange + zpadding
    
    out_img = interpolate.interpn((range(normalblurdata.shape[0]), range(normalblurdata.shape[1]),
                               range(normalblurdata.shape[2])), normalblurdata, (dimx, dimy, dimz))
    return out_img

img = cv2.imread("iitk.jpg")

lab = cv2.cvtColor(img,cv2.COLOR_BGR2LAB) 
l, a, b = cv2.split(lab)
l=l/100.0
l = l.astype("float32")
result = rt_BF(l, 75.0, 0.2)
result= result*100.0
result = np.uint8(result)
result = cv2.merge((result,a,b))
result = cv2.cvtColor(result,cv2.COLOR_LAB2BGR)

import numpy as np
import cv2

def my_SEG(img):
  # img = result.copy()
  img = cv2.cvtColor(img,cv2.COLOR_BGR2RGB)
  img2d = img.reshape((-1,3))
  img2d = np.float32(img2d)

  _, label, _ = cv2.kmeans(img2d, 2, None, (cv2.TERM_CRITERIA_EPS + cv2.TERM_CRITERIA_MAX_ITER, 10, 0.5), 5, cv2.KMEANS_PP_CENTERS)

  label_reshaped = label.reshape((img.shape[:2]))
  label_reshaped = label_reshaped.astype('uint8')
  _, thresh1 = cv2.threshold(label_reshaped, 0, 255, cv2.THRESH_BINARY_INV)

  b = cv2.GaussianBlur(thresh1,(13,13),5)

  _, out = cv2.threshold(b, 200, 255, cv2.THRESH_BINARY)

  return out

  

img_seg = my_SEG(result.copy())
cv2_imshow(img_seg)
cv2.imwrite('fordrone.jpg', img_seg)